#include "Arduino.h"
#include <Wire.h>
#include <MPU6050.h>
#include <L298N.h>
#include <PID_v1.h>
int16_t AcX,AcY,AcZ,Tmp,GyX,GyY,GyZ;
int minVal=265;
int maxVal=402;
int ENA = 5;
int IN1 = 19;
float speed_factor = 1.9;
int IN2 = 18;
double x;
double y;
double z;
double speed;
MPU6050 mpu;

// Create L298N motor object
L298N motor(ENA, IN1, IN2);

const float sensor_bias = 0.98;
const float GYRO_SENS = 131.0;

float compl_filter = 0;
unsigned long lastTime = 0;

// Define equilibrium zone and parameters
const float EQUILIBRIUM_ZONE = 10.0; // Dead zone around 0/360 degrees  
const int MIN_SPEED = 50; // Minimum speed to ensure motor movement
const int MAX_SPEED = 255; // Maximum motor speed

void setup(){
  Wire.begin(21, 22);
  Serial.begin(115200);
  mpu.initialize();
  Serial.println("connect MPU6050");
  lastTime = millis(); //set last time to time @ setup
  
  // L298N library handles pin initialization
  motor.setSpeed(0); // Initialize with 0 speed
}

void loop(){
  int16_t ax, ay, az;
  int16_t gx, gy, gz;
  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
  unsigned long now = millis();
  float dt = (now - lastTime) / 1000.0; // Calculate dt BEFORE updating lastTime
  lastTime = now; // Update lastTime AFTER calculating dt
  
  if (dt > 1.0 || dt <= 0) {
    return;
  }
  
  float gyroRate = static_cast<float>(gz) / GYRO_SENS * DEG_TO_RAD;
  float accelAngle = atan2((float)ay, -1 * (float)ax);
  compl_filter = (sensor_bias * (compl_filter + gyroRate * dt)) +
                 (1 - sensor_bias) * accelAngle;
  
  Serial.println(fmod(compl_filter * RAD_TO_DEG+360.0,360));
  z = fmod(compl_filter * RAD_TO_DEG+360.0,360);
  
  // Calculate distance from equilibrium (0/360 degrees)
  float angle_error;
  bool is_right_side = false;
  
  // Better equilibrium detection - check for both 0° and 360° areas
  if (z >= 350 || z <= 10) {
    Serial.println("Equilibrium");
    motor.stop();
    return;
  }
  
  if (z > 180) {
    // Right side (180-360), calculate distance from 360
    angle_error = 180 - z;
    is_right_side = true;
  } else {
    // Left side (0-180), use the angle directly
    angle_error = z;
    is_right_side = false;
  }
  
  // Calculate proportional speed based on angle error
  // Use direct mapping with minimum speed threshold
  speed = map(angle_error, 0, 180, 50, 255); // Min speed 50 to ensure movement
  speed = constrain(speed, 50, 255); // Ensure minimum speed for movement
  speed = speed * speed_factor;
  speed = constrain(speed, 50, 255); // Constrain again after applying factor
  
  Serial.print("Angle: ");
  Serial.print(z);
  Serial.print(", Angle Error: ");
  Serial.print(angle_error);
  Serial.print(", Speed: ");
  Serial.print(speed);
  Serial.print(", Side: ");
  Serial.println(is_right_side ? "RIGHT" : "LEFT");
  
  // Set speed first, then direction
  motor.setSpeed(speed);
  if (is_right_side) {
    // Right side - move left (correct direction)
    motor.backward(); // Use backward() for left movement
    Serial.println("-> Moving LEFT to correct right tilt");
  } else {
    // Left side - move right (correct direction)
    motor.forward(); // Use forward() for right movement
    Serial.println("-> Moving RIGHT to correct left tilt");
  }
  
  delay(10);
}